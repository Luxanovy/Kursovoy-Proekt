#include "MyForm.h"
#define _CRT_SECURE_NO_WARNINGS
#include <windows.h>
#include <commctrl.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <MsHtmcid.h>

using namespace std;
using namespace Project1;


#define ID_TOOLBAR    100

#define ID_LISTVIEW_1   3001
#define ID_LISTVIEW_2   3002

#define ID_COMBOBOX_1	4001
#define ID_COMBOBOX_2	4002

#define ID_LABEL_1      5001
#define ID_LABEL_2      5002
#define ID_LABEL_3      5003
#define ID_LABEL_4      5004

LRESULT CALLBACK WndProc(HWND, UINT, UINT, LONG);

char szMainClass[] = "MainClass";
char dir[MAX_PATH] = "C:\\*";
char dir1[MAX_PATH] = "C:\\*";
char copy_buf1[MAX_PATH];

HINSTANCE hInstance;
HWND hWndChild = NULL;
HIMAGELIST g_hImageList = NULL;

static HWND hListView_1, hListView_2;
static HWND hComboBox_1, hComboBox_2;
static HWND hLabel_1, hLabel_2, hLabel_3, hLabel_4, hToolBar;

const int ImageListID = 0;
const int numButtons = 5;
const DWORD buttonStyles = BTNS_AUTOSIZE;
const int bitmapSize = 16;
int i;

TBBUTTON tbButtons[numButtons];

void InitToolbar()
{
	tbButtons[0].iBitmap = MAKELONG(STD_FILENEW, ImageListID); 
	tbButtons[0].idCommand = IDM_NEW;
	tbButtons[0].fsState = TBSTATE_ENABLED;
	tbButtons[0].fsStyle = buttonStyles;
	tbButtons[0].dwData = 0L;
	tbButtons[0].iString = (INT_PTR)"Notepad";

	tbButtons[1].iBitmap = MAKELONG(STD_PROPERTIES, ImageListID);
	tbButtons[1].idCommand = IDM_RENAME;
	tbButtons[1].fsState = TBSTATE_ENABLED;
	tbButtons[1].fsStyle = buttonStyles;
	tbButtons[1].dwData = 0L;
	tbButtons[1].iString = (INT_PTR)"Rename";

	tbButtons[2].iBitmap = MAKELONG(STD_REDOW, ImageListID);
	tbButtons[2].idCommand = IDM_MOVE;
	tbButtons[2].fsState = TBSTATE_ENABLED;
	tbButtons[2].fsStyle = buttonStyles;
	tbButtons[2].dwData = 0L;
	tbButtons[2].iString = (INT_PTR)"Move";

	tbButtons[3].iBitmap = MAKELONG(STD_COPY, ImageListID); 
	tbButtons[3].idCommand = IDM_COPY;
	tbButtons[3].fsState = TBSTATE_ENABLED;
	tbButtons[3].fsStyle = BTNS_AUTOSIZE;
	tbButtons[3].dwData = 0L;
	tbButtons[3].iString = (INT_PTR)"Copy";

	tbButtons[4].iBitmap = MAKELONG(STD_DELETE, ImageListID); 
	tbButtons[4].idCommand = IDM_DELETE;
	tbButtons[4].fsState = TBSTATE_ENABLED;
	tbButtons[4].fsStyle = buttonStyles;
	tbButtons[4].dwData = 0L;
	tbButtons[4].iString = (INT_PTR)"Delete";
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
	MSG Msg;
	HWND hWnd;
	WNDCLASS WndClass;

	WndClass.style = CS_VREDRAW | CS_HREDRAW;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.lpfnWndProc = WndProc;
	WndClass.hInstance = hInstance;
	WndClass.hCursor = (HCURSOR)LoadImage(0,0, IMAGE_CURSOR, SM_CXCURSOR, SM_CYCURSOR, LR_VGACOLOR); //LoadCursor(NULL, IDC_ARROW);
	WndClass.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
	WndClass.hIcon = (HICON)LoadImage(0, 0, IMAGE_ICON, SM_CXCURSOR, SM_CYCURSOR, LR_VGACOLOR);//LoadIcon(NULL, IDI_APPLICATION);
	WndClass.lpszMenuName = NULL;
	WndClass.lpszClassName = szMainClass;

	if (!RegisterClass(&WndClass))
		return FALSE;

	hWnd = CreateWindow(
		szMainClass,//имя класса
		"FILE MANAGER",//заголовок окна
		WS_BORDER | WS_SYSMENU | WS_VISIBLE, //тип окошка (включает отображение системного меню, кнопок в верхнем правом углу и т.п.)
		100, 100,//место появления окна (координаты х и y). Здесь указано место “по умолчанию”, поэтому второй параметр игнорируется
		910, 620,//ширина окна (определяется аналогично месту появления)
		0, //ссылка на родительское окно
		0,//хендл меню
		hInstance,
		0);//код, передаваемый с сообщением WM_CREATE

	MSG msg = {};
	while (msg.message != WM_QUIT)
	{
		if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}
	return Msg.wParam;
}

HWND CreateSimpleToolbar(HWND hWndParent)
{
	//создание тулбара
	HWND hWndToolbar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, WS_CHILD | TBSTYLE_WRAPABLE, 0, 0, 0, 0, hWndParent, NULL, hInstance, NULL);
	if (hWndToolbar == NULL)
	{
		return NULL;
	}

	//создание списка картинок, для кнопок
	g_hImageList = ImageList_Create(bitmapSize, bitmapSize, ILC_COLOR16 | ILC_MASK, numButtons, 0);

	SendMessage(hWndToolbar, TB_SETIMAGELIST, (WPARAM)ImageListID, (LPARAM)g_hImageList);
	SendMessage(hWndToolbar, TB_LOADIMAGES, (WPARAM)IDB_STD_SMALL_COLOR, (LPARAM)HINST_COMMCTRL);

	InitToolbar();

	SendMessage(hWndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
	SendMessage(hWndToolbar, TB_ADDBUTTONS, (WPARAM)numButtons, (LPARAM)&tbButtons);
	SendMessage(hWndToolbar, TB_AUTOSIZE, 0, 0);

	ShowWindow(hWndToolbar, TRUE);
	return hWndToolbar;
}

void AddColumnToListView(char* st, int sub, int size)
{
	LVCOLUMN lvc;
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	lvc.iSubItem = sub;
	lvc.pszText = st;
	lvc.cx = size;
	lvc.fmt = LVCFMT_LEFT;

	ListView_InsertColumn(hListView_1, sub, &lvc);
	ListView_InsertColumn(hListView_2, sub, &lvc);
}

BOOL InitializationListViewImage(HWND hWndListView, int size, char c_dir[MAX_PATH])
{
	HIMAGELIST hSmall;
	SHFILEINFO lp;
	hSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_MASK | ILC_COLOR32, size + 2, 1);

	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	hFind = FindFirstFile(c_dir, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE) {
		MessageBoxA(0, "Ошибка", "Не найден", MB_OK | MB_ICONWARNING);
	}
	else
	{
		do { //присвоение атрибутов
			if (strcmp(FindFileData.cFileName, ".") == 0) { //Если диск
				char buf1[MAX_PATH];
				strcpy(buf1, c_dir);
				strcat(buf1, FindFileData.cFileName);
				SHGetFileInfo("", FILE_ATTRIBUTE_DEVICE, &lp, sizeof(lp), SHGFI_ICONLOCATION | SHGFI_ICON | SHGFI_SMALLICON);

				ImageList_AddIcon(hSmall, lp.hIcon);
				DestroyIcon(lp.hIcon);
			}
			if (strcmp(FindFileData.cFileName, "..") == 0)  {// Если фаилы,папки
				char buf1[MAX_PATH];
				strcpy(buf1, c_dir);
				strcat(buf1, FindFileData.cFileName);
				SHGetFileInfo("", FILE_ATTRIBUTE_DIRECTORY, &lp, sizeof(lp), SHGFI_ICONLOCATION | SHGFI_ICON | SHGFI_SMALLICON);
				ImageList_AddIcon(hSmall, lp.hIcon);
				DestroyIcon(lp.hIcon);
			}
			char buf1[MAX_PATH]; // Присвоение иконки
			strcpy(buf1, c_dir);
			buf1[strlen(buf1) - 1] = 0;
			strcat(buf1, FindFileData.cFileName);
			DWORD num = GetFileAttributes(buf1);
			SHGetFileInfo(buf1, num, &lp, sizeof(lp), SHGFI_ICONLOCATION | SHGFI_ICON | SHGFI_SMALLICON);
			ImageList_AddIcon(hSmall, lp.hIcon);
			DestroyIcon(lp.hIcon);
		} while (FindNextFile(hFind, &FindFileData) != 0);
		FindClose(hFind);
	}
	ListView_SetImageList(hWndListView, hSmall, LVSIL_SMALL);
	return TRUE;
}

void View_List(char* buf, HWND hList, int i, int j)
{
	LVITEM lvItem;
	lvItem.mask = LVIF_IMAGE | LVIF_TEXT;
	lvItem.state = 0;
	lvItem.stateMask = 0;
	lvItem.iItem = i;
	lvItem.iImage = i;
	lvItem.iSubItem = j;
	lvItem.pszText = buf;
	lvItem.cchTextMax = sizeof(buf);
	ListView_InsertItem(hList, &lvItem);
}

void FindFile(HWND hList, char c_dir[MAX_PATH])
{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind; // Дескриптор к объекту HWND ручка к окну
	i = 0;

	SendMessage(hList, LVM_DELETEALLITEMS, (WPARAM)0, (LPARAM)0);
	hFind = FindFirstFile(c_dir, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE) {
		MessageBoxA(0, "Ошибка", "Не найден", MB_OK | MB_ICONWARNING);
	}
	else
	{
		do
		{
			if ((FILE_ATTRIBUTE_DIRECTORY & GetFileAttributes(FindFileData.cFileName)) != FILE_ATTRIBUTE_DIRECTORY)
				View_List("1", hList, i, 1); 
			else View_List("2", hList, i, 1);

			View_List(FindFileData.cFileName, hList, i, 0);
			++i;
		} while (FindNextFile(hFind, &FindFileData) != 0);

		(hFind); // Закрытие работу поиска фаилов
		InitializationListViewImage(hList, i, c_dir); 
	}
}

void Rename()
{
	char cm_dir_from[MAX_PATH];
	strcpy(cm_dir_from, dir);
	cm_dir_from[strlen(cm_dir_from) - 1] = 0;
	strcat(cm_dir_from, copy_buf1);

	TCHAR from[MAX_PATH];
	ZeroMemory(from, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(from, cm_dir_from, sizeof(TCHAR) * strlen(cm_dir_from));

	SHFILEOPSTRUCT file_move;
	ZeroMemory(&file_move, sizeof(SHFILEOPSTRUCT));
	file_move.hwnd = NULL;
	file_move.wFunc = FO_MOVE;
	file_move.pFrom = cm_dir_from;
	file_move.fFlags = FOF_RENAMEONCOLLISION;
	int result = SHFileOperation(&file_move);
	if (result != 0)
	{
		MessageBoxA(0, "Файл не переименован.", "", MB_ICONEXCLAMATION);
	}
	else
	{
		FindFile(hListView_1, dir);
	}
}

void Move()
{
	char cm_dir_from[MAX_PATH];
	char cm_dir_to[MAX_PATH], cm_dir_to_[MAX_PATH];
	strcpy(cm_dir_from, dir);
	cm_dir_from[strlen(cm_dir_from) - 1] = 0;
	strcat(cm_dir_from, copy_buf1);
	strcpy(cm_dir_to, dir1);
	strcpy(cm_dir_to_, dir1);
	cm_dir_to[strlen(cm_dir_to) - 1] = 0;
	strcat(cm_dir_to, copy_buf1);

	TCHAR from[MAX_PATH];
	ZeroMemory(from, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(from, cm_dir_from, sizeof(TCHAR) * strlen(cm_dir_from));

	TCHAR to[MAX_PATH];
	ZeroMemory(to, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(to, cm_dir_to, sizeof(TCHAR) * strlen(cm_dir_to));

	SHFILEOPSTRUCT file_move;
	ZeroMemory(&file_move, sizeof(SHFILEOPSTRUCT));
	file_move.hwnd = NULL;
	file_move.wFunc = FO_MOVE;
	file_move.pFrom = from;
	file_move.pTo = to;
	file_move.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS;
	int message = MessageBoxA(0, cm_dir_from, "Вы точно хотите переместить файл?", MB_ICONQUESTION | MB_OKCANCEL);
	if (message != IDCANCEL)
	{
		MessageBoxA(0, cm_dir_to, "Перемещение в:", MB_ICONEXCLAMATION);
		int result = SHFileOperation(&file_move);
		if (result != 0)
		{
			MessageBoxA(0, "Файл не перемещён.", "", MB_ICONEXCLAMATION);
		}
		else
		{
			FindFile(hListView_1, dir);
			FindFile(hListView_2, cm_dir_to_);
			MessageBoxA(0, "Файл перемещён.", "", MB_ICONEXCLAMATION);
		}
	}
}

void notepad()
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(STARTUPINFO));
	ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USEPOSITION;
	si.wShowWindow = SW_MAXIMIZE;
	CreateProcess(NULL, "NOTEPAD", NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
}

void CopyFile()
{
	char cm_dir_from[MAX_PATH];
	char cm_dir_to[MAX_PATH], cm_dir_to_[MAX_PATH];
	strcpy(cm_dir_from, dir);
	cm_dir_from[strlen(cm_dir_from) - 1] = 0;
	strcat(cm_dir_from, copy_buf1);
	strcpy(cm_dir_to, dir1);
	strcpy(cm_dir_to_, dir1);
	cm_dir_to[strlen(cm_dir_to) - 1] = 0;
	strcat(cm_dir_to, copy_buf1);

	TCHAR from[MAX_PATH];
	ZeroMemory(from, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(from, cm_dir_from, sizeof(TCHAR) * strlen(cm_dir_from));

	TCHAR to[MAX_PATH];
	ZeroMemory(to, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(to, cm_dir_to, sizeof(TCHAR) * strlen(cm_dir_to));

	SHFILEOPSTRUCT file_copy;
	ZeroMemory(&file_copy, sizeof(SHFILEOPSTRUCT));
	file_copy.hwnd = NULL;
	file_copy.wFunc = FO_COPY;
	file_copy.pFrom = from;
	file_copy.pTo = to;
	file_copy.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS;
	int message = MessageBoxA(0, cm_dir_from, "Вы точно хотите скопировать файл?", MB_ICONQUESTION | MB_OKCANCEL);
	if (message != IDCANCEL)
	{
		MessageBoxA(0, cm_dir_to, "Копирование в:", MB_ICONEXCLAMATION);
		int result = SHFileOperation(&file_copy);
		if (result != 0)
		{
			MessageBoxA(0, "Файл не скопирован.", "", MB_ICONEXCLAMATION);
		}
		else 
		{
			FindFile(hListView_2, cm_dir_to_);
			MessageBoxA(0, "Файл скопирован.", "", MB_ICONEXCLAMATION);
		}
	}
}

void DelFile()
{
	char cm_dir_from[MAX_PATH], cm_dir_from_[MAX_PATH];
	strcpy(cm_dir_from, dir);
	strcpy(cm_dir_from_, dir);
	cm_dir_from[strlen(cm_dir_from) - 1] = 0;
	strcat(cm_dir_from, copy_buf1);

	TCHAR _basket[MAX_PATH];
	ZeroMemory(_basket, sizeof(TCHAR) * MAX_PATH);
	CopyMemory(_basket, cm_dir_from, sizeof(TCHAR) * strlen(cm_dir_from));
	SHFILEOPSTRUCT file_del;
	ZeroMemory(&file_del, sizeof(SHFILEOPSTRUCT));
	file_del.hwnd = NULL;
	file_del.wFunc = FO_DELETE;
	file_del.pFrom = _basket;
	file_del.fFlags = FOF_ALLOWUNDO | FOF_NOCONFIRMATION | FOF_SIMPLEPROGRESS;
	int message = MessageBoxA(0,cm_dir_from, "Вы точно хотите удалить файл?", MB_ICONQUESTION | MB_OKCANCEL);
	if (message != IDCANCEL)
	{
		int result = SHFileOperation(&file_del);
		if (result != 0)
		{
			MessageBoxA(0, "Файл не удалён.", "", MB_ICONEXCLAMATION);
		}
		else {
			FindFile(hListView_1, cm_dir_from_);
			FindFile(hListView_2, cm_dir_from_); 
			MessageBoxA(0, "Файл удалён.", "", MB_ICONEXCLAMATION); 
		}
	}
}

void ComboProcessing(HWND hComboBox, HWND hLabel, HWND hListView, char _dir[MAX_PATH])
{
	char path[80];
	int sel;
	strcpy(path, "");
	sel = SendMessage(hComboBox, CB_GETCURSEL, 0, 0);
	SendMessage(hComboBox, CB_GETLBTEXT, sel, (LPARAM)path);
	strcat(path, "\*");
	strcpy(_dir, path);
	SetWindowText(hLabel, _dir);
	FindFile(hListView, _dir);
}

LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	DWORD Drivers;

	int i, k;
	char c;
	char buf[] = " ";
	char* ls;
	string s;
	int y = 9;
	char buf1[MAX_PATH];

	LPNMHDR lpnmHdr;
	lpnmHdr = (LPNMHDR)lParam;
	LPNMLISTVIEW pnmLV = (LPNMLISTVIEW)lParam;

	GetLogicalDrives();
	GetLogicalDriveStrings(128, (LPTSTR)buf);

	switch (msg)
	{
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDM_NEW:
		{
			notepad();
			return 0;
		}
		case IDM_RENAME:
		{
			Rename();
			return 0;
		}
		case IDM_MOVE:
		{
			Move();
			return 0;
		}
		case IDM_COPY:
		{
			CopyFile();
			return 0;
		}
		case IDM_DELETE:
		{
			DelFile();
			return 0;
		}
		case ID_COMBOBOX_1:
		{
			switch (HIWORD(wParam))
			{
			case CBN_SELENDOK:
			{
				ComboProcessing(hComboBox_1, hLabel_3, hListView_1, dir);
				return 0;
			}
			default: return 0;
			}
		}
		case ID_COMBOBOX_2:
		{
			switch (HIWORD(wParam))
			{
			case CBN_SELENDOK:
			{
				ComboProcessing(hComboBox_2, hLabel_4, hListView_2, dir1);
				return 0;
			}
			default: return 0;
			}
		}
		return 0;
		}
	}
	case WM_NOTIFY:
	{

		if (((lpnmHdr->idFrom == ID_LISTVIEW_1) /*|| (lpnmHdr->idFrom == ID_LISTVIEW_2)*/) && (lpnmHdr->code == NM_CLICK))
		{
			ListView_GetItemText(lpnmHdr->hwndFrom, pnmLV->iItem, pnmLV->iSubItem, buf1, MAX_PATH);
			strcpy(copy_buf1, buf1);

			char _dir[MAX_PATH];
			strcpy(_dir, dir);
			_dir[strlen(_dir) - 1] = 0;
			strcat(_dir, buf1);

			SendMessage(hToolBar, TB_SETSTATE, (WPARAM)IDM_NEW, (LPARAM)MAKELONG(TBSTATE_ENABLED, 0));
			SendMessage(hToolBar, TB_SETSTATE, (WPARAM)IDM_RENAME, (LPARAM)MAKELONG(TBSTATE_ENABLED, 0));
			SendMessage(hToolBar, TB_SETSTATE, (WPARAM)IDM_MOVE, (LPARAM)MAKELONG(TBSTATE_ENABLED, 0));
			SendMessage(hToolBar, TB_SETSTATE, (WPARAM)IDM_COPY, (LPARAM)MAKELONG(TBSTATE_ENABLED, 0));
			SendMessage(hToolBar, TB_SETSTATE, (WPARAM)IDM_DELETE, (LPARAM)MAKELONG(TBSTATE_ENABLED, 0));
		}
		if (((lpnmHdr->idFrom == ID_LISTVIEW_1) || (lpnmHdr->idFrom == ID_LISTVIEW_2)) && (lpnmHdr->code == NM_DBLCLK))
		{
			// Копирование строки в буфер из ячейки ListView (pnmLV->iItem - номер строки;
			// pnmLV->iSubItem - номер столбца)
			ListView_GetItemText(lpnmHdr->hwndFrom, pnmLV->iItem, pnmLV->iSubItem, buf1, MAX_PATH);

			if (lpnmHdr->idFrom == ID_LISTVIEW_1)
			{
				char _dir[MAX_PATH];
				int k = 0;
				strcpy(_dir, dir);
				_dir[strlen(_dir) - 1] = 0;
				strcat(_dir, buf1);

				for (int i = 0; i < strlen(buf1); i++)
				{
					string s;
					s = buf1[i];
					if (s == ".") k = i;
				}

				if ((k != 0) && (k != 1))
				{
					ShellExecute(0, "open", _dir, NULL, NULL, SW_SHOWNORMAL);
				}
				else
				{
					if (strcmp(buf1, "..") == 0)
					{
						int k;
						dir[strlen(dir) - 2] = 0;
						for (i = 0; i < strlen(dir); i++)
						{
							string s;
							s = dir[i];
							if (s == "\\") k = i;
						}
						dir[k + 1] = 0;
						strcat(dir, "*");
					}
					else if (strcmp(buf1, ".") == 0)
					{
						dir[3] = 0;
						strcat(dir, "*");
					}
					else
					{
						strcat(buf1, "\\*");
						dir[strlen(dir) - 1] = 0;
						strcat(dir, buf1);
					}
					SetWindowText(hLabel_3, dir);
					FindFile(hListView_1, dir);
				}
			}
			else if (lpnmHdr->idFrom == ID_LISTVIEW_2)
			{
				char _dir1[MAX_PATH];
				int k = 0;
				strcpy(_dir1, dir1);
				_dir1[strlen(_dir1) - 1] = 0;
				strcat(_dir1, buf1);

				for (int i = 0; i < strlen(buf1); i++)
				{
					string s;
					s = buf1[i];
					if (s == ".") k = i;
				}

				if ((k != 0) && (k != 1))
				{
					ShellExecute(0, "open", _dir1, NULL, NULL, SW_SHOWNORMAL);
				}
				else
				{
					if (strcmp(buf1, "..") == 0)
					{
						int k;
						dir1[strlen(dir1) - 2] = 0;
						for (i = 0; i < strlen(dir1); i++)
						{
							string s;
							s = dir1[i];
							if (s == "\\") k = i;
						}
						dir1[k + 1] = 0;
						strcat(dir1, "*");
					}
					else if (strcmp(buf1, ".") == 0)
					{
						dir1[3] = 0;
						strcat(dir1, "*");
					}
					else
					{
						strcat(buf1, "\\*");
						dir1[strlen(dir1) - 1] = 0;
						strcat(dir1, buf1);
					}
					SetWindowText(hLabel_4, dir1);
					FindFile(hListView_2, dir1);
				}
			}
		}
		break;
	}
	case WM_CREATE:
	{
		hToolBar = CreateSimpleToolbar(hwnd);

		hLabel_3 = CreateWindow("static", "way1",	WS_CHILD | WS_VISIBLE | WS_TABSTOP,	3, 57 + y, 400, 16,	hwnd, (HMENU)ID_LABEL_3, hInstance, NULL);
		hLabel_4 = CreateWindow("static", "way2",	WS_CHILD | WS_VISIBLE | WS_TABSTOP,	453, 57 + y, 400, 16,	hwnd, (HMENU)ID_LABEL_4, hInstance, NULL);

		hComboBox_1 = CreateWindow("ComboBox", NULL,	WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWN | CBS_SORT, 3, 33 + y, 100, 110, hwnd,	(HMENU)ID_COMBOBOX_1, hInstance, NULL);
		hComboBox_2 = CreateWindow("ComboBox", NULL,WS_CHILD | WS_VISIBLE | WS_VSCROLL | CBS_DROPDOWN | CBS_SORT, 453, 33 + y, 100, 110, hwnd,(HMENU)ID_COMBOBOX_2, hInstance, NULL);

		hListView_1 = CreateWindow(WC_LISTVIEW, NULL,LVS_REPORT | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | LVS_AUTOARRANGE, 0, 60 + y + 15, 450, 500, hwnd,(HMENU)ID_LISTVIEW_1, hInstance, NULL);
		hListView_2 = CreateWindow(WC_LISTVIEW, NULL,LVS_REPORT | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | LVS_AUTOARRANGE, 451, 60 + y + 15, 450, 500, hwnd,(HMENU)ID_LISTVIEW_2, hInstance, NULL);

		ls = buf;
		while (*ls)
		{
			SendMessage(hComboBox_1, CB_ADDSTRING, 0, (LPARAM)ls);
			SendMessage(hComboBox_2, CB_ADDSTRING, 0, (LPARAM)ls);
			ls += strlen(ls) + 1;
		}

		SendMessage(hComboBox_1, CB_SETCURSEL, 1, 0);
		SendMessage(hComboBox_2, CB_SETCURSEL, 1, 0);

		AddColumnToListView("Имя", 1, 100);
		FindFile(hListView_1, dir);
		SetWindowText(hLabel_3, dir);
		FindFile(hListView_2, dir);
		SetWindowText(hLabel_4, dir1);
		return 0;
	}
	case WM_DESTROY:
	{
		DestroyWindow(hListView_1);
		DestroyWindow(hListView_2);
		DestroyWindow(hComboBox_1);
		DestroyWindow(hComboBox_2);
		DestroyWindow(hLabel_1);
		DestroyWindow(hLabel_2);
		DestroyWindow(hLabel_3);
		DestroyWindow(hLabel_4);
		DestroyWindow(hToolBar);
		PostQuitMessage(0);
		return 0;
	}
	}
	return DefWindowProc(hwnd, msg, wParam, lParam);
}
